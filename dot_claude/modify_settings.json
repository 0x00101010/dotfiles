#!/bin/bash
# chezmoi modify_ script for .claude/settings.json
# Deep-merges base settings (from repo) into the existing target file,
# preserving any locally-injected keys (e.g. company env vars, marketplace config).
#
# Behavior:
# - Top-level keys from base overwrite existing (permissions, model, plugins, etc.)
# - Top-level keys only in existing are preserved (includeCoAuthoredBy, extraKnownMarketplaces, etc.)
# - "env" is deep-merged: existing env vars preserved, base env vars added/updated on top

set -euo pipefail

BASE_CONFIG='
{
  "alwaysThinkingEnabled": false,
  "permissions": {
    "allow": [
      "WebFetch(domain:github.com)",
      "WebFetch(domain:gist.github.com)",
      "WebFetch(domain:api.github.com)",
      "WebFetch(domain:raw.githubusercontent.com)",
      "Fetch",
      "WebSearch",
      "Base(cd:*)",
      "Bash(make:*)",
      "Bash(ls:*)",
      "Bash(cat:*)",
      "Bash(less:*)",
      "Bash(head:*)",
      "Bash(tail:*)",
      "Bash(more:*)",
      "Bash(ping:*)",
      "Bash(curl:*)",
      "Bash(ifconfig:*)",
      "Bash(ip:*)",
      "Bash(pwd:*)",
      "Bash(mkdir:*)",
      "Bash(tree:*)",
      "Bash(awk:*)",
      "Bash(sed:*)",
      "Bash(wc:*)",
      "Bash(grep:*)",
      "Bash(cut:*)",
      "Bash(sort:*)",
      "Bash(uniq:*)",
      "Bash(diff:*)",
      "Bash(file:*)",
      "Bash(find:*)",
      "Bash(xargs:*)",
      "Bash(locate:*)",
      "Bash(which:*)",
      "Bash(whereis:*)",
      "Bash(cargo:*)",
      "Bash(forge:*)",
      "Bash(cast:*)",
      "Bash(git status:*)",
      "Bash(git log:*)",
      "Bash(git show:*)",
      "Bash(git diff:*)",
      "Bash(git branch:*)",
      "Bash(git remote:*)",
      "Bash(git tag:*)",
      "Bash(git ls-files:*)",
      "Bash(git ls-tree:*)",
      "Bash(git ls-remote:*)",
      "Bash(git reflog:*)",
      "Bash(git rev-parse:*)",
      "Bash(git rev-list:*)",
      "Bash(git describe:*)",
      "Bash(git cat-file:*)",
      "Bash(git blame:*)",
      "Bash(git grep:*)",
      "Bash(git config --get:*)",
      "Bash(git config --list:*)",
      "Bash(git config -l:*)",
      "Bash(git shortlog:*)",
      "Bash(git count-objects:*)",
      "Bash(git fsck:*)",
      "Bash(git verify-:*)",
      "Bash(gh project:*)",
      "Bash(gh issue list:*)",
      "Bash(gh issue view:*)",
      "Bash(gh:*)",
      "Base(just:*)",
      "Read(//private/tmp/**)",
      "Read(//tmp/**)",
      "Read(/home/**/src/**)",
      "Read(/Users/**/src/**)",
      "Read(~/src/**)"
    ],
    "deny": [
      "Read(.env*)",
      "Read(**/secrets/**)",
      "Read(**/*.key)"
    ]
  },
  "model": "opus[1m]",
  "enabledPlugins": {
    "rust-analyzer-lsp@claude-plugins-official": true,
    "hookify@claude-plugins-official": true,
    "ralph-loop@claude-plugins-official": true
  },
  "sandbox": {
    "enabled": false
  },
  "env": {
    "CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS": "1"
  },
  "plansDirectory": "~/.claude/plans",
  "statusLine": {
    "type": "command",
    "command": "bash ~/.claude/statusline.sh"
  },
  "outputStyle": "explanatory"
}
'

# Read current target from stdin (may be empty on first run)
EXISTING=$(cat)

if [ -z "$EXISTING" ] || ! echo "$EXISTING" | jq empty 2>/dev/null; then
  # No existing file or invalid JSON â€” use base config as-is
  echo "$BASE_CONFIG" | jq .
else
  # Deep-merge: existing * base, with special handling for "env"
  # 1. Merge env separately (existing env + base env, base wins on conflicts)
  # 2. Merge everything else (base wins on conflicts, existing-only keys preserved)
  echo "$EXISTING" | jq --argjson base "$BASE_CONFIG" '
    # Deep merge env: existing.env + base.env (base wins)
    ((.env // {}) * ($base.env // {})) as $merged_env |
    # Shallow merge top-level: existing + base (base wins), then set merged env
    . * $base |
    .env = $merged_env
  '
fi
